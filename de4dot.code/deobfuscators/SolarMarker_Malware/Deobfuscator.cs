/*
    Copyright (C) 2011-2015 de4dot@gmail.com

    This file is part of de4dot.

    de4dot is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    de4dot is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with de4dot.  If not, see <http://www.gnu.org/licenses/>.
*/

using System;
using System.Linq;
using System.Collections.Generic;
using dnlib.DotNet;
using de4dot.blocks;
using de4dot.code.AssemblyClient;
using dnlib.DotNet.Emit;

namespace de4dot.code.deobfuscators.SolarMaker_Malware {
	public class DeobfuscatorInfo : DeobfuscatorInfoBase {
		public const string THE_NAME = "SolarMaker_Malware";
		public const string THE_TYPE = "sm_m";
		const string DEFAULT_REGEX = DeobfuscatorBase.DEFAULT_VALID_NAME_REGEX;

		public DeobfuscatorInfo()
			: base(DEFAULT_REGEX) {
		}

		public override string Name => THE_NAME;
		public override string Type => THE_TYPE;

		public override IDeobfuscator CreateDeobfuscator() =>
			new Deobfuscator(new Deobfuscator.Options {
				ValidNameRegex = validNameRegex.Get(),
                RenameResourcesInCode = false,
			});
	}

	class Deobfuscator : DeobfuscatorBase {
		internal class Options : OptionsBase {
		}
		public override string Type => DeobfuscatorInfo.THE_TYPE;
		public override string TypeLong => DeobfuscatorInfo.THE_NAME;
		public override string Name => DeobfuscatorInfo.THE_NAME;
		List<MethodDef> solarMakerStringMethods = new List<MethodDef>();
        Dictionary<int, String> stringMethodToString = new Dictionary<int, string>();
		private List<MDToken> emptyMethodTokens = new List<MDToken>();

		public Deobfuscator(Options options)
			: base(options) {
		}

		public override void Initialize(ModuleDefMD module) {
			base.Initialize(module);
		}

		protected override int DetectInternal() {
			int val = 0;
			if (solarMakerStringMethods.Count > 5) {
				//val += 100;
			}
			return val;
		}

		protected override void ScanForObfuscator() {
			solarMakerStringMethods = GetSolarMakerStringObfuscationFunctions(module);
		}

		public override void DeobfuscateBegin() {
			base.DeobfuscateBegin();

            using (var assemblyClient = new NewProcessAssemblyClientFactory().Create(AssemblyData.AssemblyServiceType.Generic)) {
                assemblyClient.Connect();
                assemblyClient.WaitConnected();

                assemblyClient.GenericService.LoadUserService(typeof(StringDecoderService), null);
                assemblyClient.GenericService.LoadAssembly(module.Location);

                foreach(var stringMethod in solarMakerStringMethods) {
                    int stringMethodToken = stringMethod.MDToken.ToInt32();
                    String moduleName = stringMethod.Module.Name;
                    String result = (String)assemblyClient.GenericService.SendMessage(StringDecoderService.MSG_CALL_METHOD, new Object[] {moduleName, stringMethodToken});
                    stringMethodToString[stringMethodToken] = result;

                    staticStringInliner.Add(stringMethod, (method, gim, args) => stringMethodToString[method.MDToken.ToInt32()]);
                }
            }

            DeobfuscatedFile.StringDecryptersAdded();
		}

		private void RemoveSimpleJunkCode(Blocks blocks) {
			List<int> junkInsIdxs = new List<int>();

			// Find only compiler generated methods - anonymous methods
			if(blocks.Method.CustomAttributes.Find("System.Runtime.CompilerServices.CompilerGeneratedAttribute") is null) {
				return;
			}

			string methodName = blocks.Method.FullName;
			var allBlocks = blocks.MethodBlocks.GetAllBlocks();
			foreach(var block in allBlocks) {
				var blockIns = block.Instructions;
				int insIdx = -1;
				foreach(Instr ins in blockIns) {
					insIdx += 1;
					if(ins.OpCode.Code == Code.Call || ins.OpCode.Code == Code.Callvirt) {
						MemberRef targetMethod = ins.Operand as MemberRef;
						if (targetMethod == null || !targetMethod.IsMethodRef) {
							continue;
						}

						String targetType = targetMethod.GetDeclaringTypeFullName();
						String targetMethodName = targetMethod.Name;
						String[] pushNumCode = { "Ldc_R", "Ldc_I" };

						// Remove statements like the following, which call Math functions and do not use their return values:
						// Math.Exp(7.919945193979257E-06);
				 		String[] knownMathMethods = { "Tan", "Exp", "Log", "Cos", "Abs" };
				 		if (targetType == "System.Math" && knownMathMethods.Contains(targetMethodName)) {
				 			Instr nextIns = blockIns[insIdx + 1];
				 			Instr prevIns = blockIns[insIdx - 1];

				 			if(nextIns.OpCode.Code == Code.Pop 
				 				&& pushNumCode.Any(c => prevIns.OpCode.Code.ToString().StartsWith(c))) {
				 				Logger.v($"Found junk math sequence:\n{prevIns}\n{ins}\n{nextIns}\n\n");
								junkInsIdxs.Add(insIdx - 1);
								junkInsIdxs.Add(insIdx);
								junkInsIdxs.Add(insIdx + 1);
				 			}
						}

						// Remove statements like the following:
						// Thread.Sleep(Math.Abs(212734) / 1000000);
						if(targetType == "System.Threading.Thread" && targetMethodName == "Sleep") {
				 			Instr prevIns1 = blockIns[insIdx - 1];
				 			Instr prevIns2 = blockIns[insIdx - 2];
				 			Instr prevIns3 = blockIns[insIdx - 3];
				 			Instr prevIns4 = blockIns[insIdx - 4];

							if (prevIns3.OpCode.Code != Code.Call && prevIns3.OpCode.Code != Code.Callvirt) {
								continue;
							}

							MemberRef targetMethod3 = prevIns3.Operand as MemberRef;
							if (targetMethod3 == null || !targetMethod3.IsMethodRef) {
								continue;
							}

							String targetType3 = targetMethod3.GetDeclaringTypeFullName();
							String targetMethodName3 = targetMethod3.Name;

							if ((prevIns1.OpCode.Code == Code.Div)
								&& (pushNumCode.Any(c => prevIns2.OpCode.Code.ToString().StartsWith(c)))
								&& (targetType3 == "System.Math" && targetMethod3.GetParamCount() == 1)
								&& (pushNumCode.Any(c => prevIns4.OpCode.Code.ToString().StartsWith(c)))) {
									Logger.v($"Found junk sleep sequence:\n{prevIns4}\n{prevIns3}\n{prevIns2}\n{prevIns1}\n{ins}\n\n");
									junkInsIdxs.Add(insIdx - 4);
									junkInsIdxs.Add(insIdx - 3);
									junkInsIdxs.Add(insIdx - 2);
									junkInsIdxs.Add(insIdx - 1);
									junkInsIdxs.Add(insIdx);
							}

						}
					}
				}

				foreach(var junkInsIdx in junkInsIdxs) {
					block.Replace(junkInsIdx, 1, OpCodes.Nop.ToInstruction());
				}
			}
		}

		private void RemoveThreadJunkCode(Blocks blocks) {
			// Remove the creation of thread below. Does not care about what
			// the target method does, assumes that it is junk code, which
			// could be easily WRONG. Some of these checks for opcodes are also
			// very brittle, and do not check for alternative instructions that
			// can perform the same actions.
			//
			// Thread thread = new Thread(delegate()
			// {
			//    ...
			// });
			// thread.Start();
			// thread.Join();
			//
			// prevIns7	0184	ldsfld	class [mscorlib]System.Threading.ThreadStart Qo4uk8IIolEArxAqB6yPG348XXBULHMrNw2M_w6FRUQLjtNG0OUkl9EP_rgdZOCfHCezzwavkah4YeOnP82Hq2ps.BD7XXhu5iQae4Ssgr1x7sFviS05xy3RUWyLU1ZeYM4dbUuycqBgKPxUlS_::'CS$<>9__CachedAnonymousMethodDelegate18'
			// prevIns6	0189	brtrue.s	142 (019C) ldsfld class [mscorlib]System.Threading.ThreadStart Qo4uk8IIolEArxAqB6yPG348XXBULHMrNw2M_w6FRUQLjtNG0OUkl9EP_rgdZOCfHCezzwavkah4YeOnP82Hq2ps.BD7XXhu5iQae4Ssgr1x7sFviS05xy3RUWyLU1ZeYM4dbUuycqBgKPxUlS_::'CS$<>9__CachedAnonymousMethodDelegate18'
			// prevIns5	018B	ldnull
			// prevIns4	018C	ldftn	void Qo4uk8IIolEArxAqB6yPG348XXBULHMrNw2M_w6FRUQLjtNG0OUkl9EP_rgdZOCfHCezzwavkah4YeOnP82Hq2ps.BD7XXhu5iQae4Ssgr1x7sFviS05xy3RUWyLU1ZeYM4dbUuycqBgKPxUlS_::'<vAW9mPPYiZletM0pnQX>b__d'()
			// prevIns3	0192	newobj	instance void [mscorlib]System.Threading.ThreadStart::.ctor(object, native int)
			// prevIns2	0197	stsfld	class [mscorlib]System.Threading.ThreadStart Qo4uk8IIolEArxAqB6yPG348XXBULHMrNw2M_w6FRUQLjtNG0OUkl9EP_rgdZOCfHCezzwavkah4YeOnP82Hq2ps.BD7XXhu5iQae4Ssgr1x7sFviS05xy3RUWyLU1ZeYM4dbUuycqBgKPxUlS_::'CS$<>9__CachedAnonymousMethodDelegate18'
			// prevIns1	019C	ldsfld	class [mscorlib]System.Threading.ThreadStart Qo4uk8IIolEArxAqB6yPG348XXBULHMrNw2M_w6FRUQLjtNG0OUkl9EP_rgdZOCfHCezzwavkah4YeOnP82Hq2ps.BD7XXhu5iQae4Ssgr1x7sFviS05xy3RUWyLU1ZeYM4dbUuycqBgKPxUlS_::'CS$<>9__CachedAnonymousMethodDelegate18'
			// ins   	01A1	newobj	instance void [mscorlib]System.Threading.Thread::.ctor(class [mscorlib]System.Threading.ThreadStart)
			// nextIns1	01A6	stloc.s	V_8 (8)
			// nextIns2	01A8	ldloc.s	V_8 (8)
			// nextIns3	01AA	callvirt	instance void [mscorlib]System.Threading.Thread::Start()
			// nextIns4	01AF	ldloc.s	V_8 (8)
			// nextIns5	01B1	callvirt	instance void [mscorlib]System.Threading.Thread::Join()

			string methodName = blocks.Method.FullName;
			var allBlocks = blocks.MethodBlocks.GetAllBlocks();
			var instructionsBuffer = new List<Tuple<int, int, Instr> >();

			{
				int blockNum = -1;
				foreach (var block in allBlocks) {
					blockNum += 1;
					int blockInsNum = -1;
					foreach (var ins in block.Instructions) {
						blockInsNum += 1;
						instructionsBuffer.Add(Tuple.Create(blockNum, blockInsNum, ins));
					}
				}
			}

			var junkInstructions = new List<System.Tuple<int, int> >();
			int insIdx = -1;
			foreach (var item in instructionsBuffer) {
				var blockNum = item.Item1;
				var blockInsNum = item.Item2;
				var ins = item.Item3;
				insIdx += 1;

				if (!(insIdx < 7 && insIdx + 5 >= instructionsBuffer.Count)
					&& ins.OpCode.Code == Code.Newobj 
					&& ins.Operand is MemberRef targetMethod 
					&& targetMethod.IsMethodRef 
					&& targetMethod.GetDeclaringTypeFullName() == "System.Threading.Thread" 
					&& targetMethod.Name == ".ctor") {
					var prevIns1 = instructionsBuffer[insIdx - 1].Item3;
					var prevIns2 = instructionsBuffer[insIdx - 2].Item3;
					var prevIns3 = instructionsBuffer[insIdx - 3].Item3;
					var prevIns4 = instructionsBuffer[insIdx - 4].Item3;
					var prevIns5 = instructionsBuffer[insIdx - 5].Item3;
					var prevIns6 = instructionsBuffer[insIdx - 6].Item3;
					var prevIns7 = instructionsBuffer[insIdx - 7].Item3;

					var nextIns1 = instructionsBuffer[insIdx + 1].Item3;
					var nextIns2 = instructionsBuffer[insIdx + 2].Item3;
					var nextIns3 = instructionsBuffer[insIdx + 3].Item3;
					var nextIns4 = instructionsBuffer[insIdx + 4].Item3;
					var nextIns5 = instructionsBuffer[insIdx + 5].Item3;

					if(prevIns7.OpCode.Code == Code.Ldsfld && prevIns7.Operand is FieldDef field7 && field7.FieldType.ToString() == "System.Threading.ThreadStart"
						&& prevIns6.OpCode.Code == Code.Brtrue_S
						&& prevIns5.OpCode.Code == Code.Ldnull
						&& prevIns4.OpCode.Code == Code.Ldftn // We currently don't use any heuristic to select target functions
						&& prevIns3.OpCode.Code == Code.Newobj && prevIns3.Operand is MemberRef member3 && member3.IsMethodRef && member3.GetDeclaringTypeFullName() == "System.Threading.ThreadStart" && member3.Name == ".ctor"
						&& prevIns2.OpCode.Code == Code.Stsfld && prevIns2.Operand is FieldDef field2 && field2 == field7
						&& prevIns1.OpCode.Code == Code.Ldsfld && prevIns1.Operand is FieldDef field1 && field1 == field7

						&& nextIns3.OpCode.Code == Code.Callvirt && nextIns3.Operand is MemberRef nmember3 && nmember3.IsMethodRef && nmember3.GetDeclaringTypeFullName() == "System.Threading.Thread" && nmember3.Name == "Start"
						&& nextIns5.OpCode.Code == Code.Callvirt && nextIns5.Operand is MemberRef nmember5 && nmember5.IsMethodRef && nmember5.GetDeclaringTypeFullName() == "System.Threading.Thread" && nmember5.Name == "Join") {

						if(!(nextIns1.OpCode.Code == Code.Stloc_S && nextIns1.Operand is Local nlocal1
								&& nextIns2.OpCode.Code == Code.Ldloc_S && nextIns2.Operand is Local nlocal2 && nlocal1 == nlocal2
								&& nextIns4.OpCode.Code == Code.Ldloc_S && nextIns4.Operand is Local nlocal4 && nlocal1 == nlocal4)) {

							// Alternatively, the following sequence of code does the same thing as well (instead of stloc.s/ldloc.s)
							// 8	0022	stloc.0
							// 9	0023	ldloc.0
							// 10	0024	callvirt	instance void [mscorlib]System.Threading.Thread::Start()
							// 11	0029	ldloc.0
							// 12	002A	callvirt	instance void [mscorlib]System.Threading.Thread::Join()
							if(!(nextIns1.IsStloc()
								 && nextIns2.IsLdloc()
								 && nextIns4.IsLdloc()
								 && nextIns1.OpCode.Code.ToString().Split('_')[1] == nextIns2.OpCode.Code.ToString().Split('_')[1]
								 && nextIns1.OpCode.Code.ToString().Split('_')[1] == nextIns4.OpCode.Code.ToString().Split('_')[1])) {
								continue;
							}
						}

						for(int i=-7; i <= 5; i++) {
							junkInstructions.Add(Tuple.Create(instructionsBuffer[insIdx + i].Item1, instructionsBuffer[insIdx + i].Item2));
						}
					}
				}
				else if (!(insIdx < 4 && insIdx + 4 >= instructionsBuffer.Count)
					&& ins.OpCode.Code == Code.Newobj
					&& ins.Operand is MemberRef targetMethod2
					&& targetMethod2.IsMethodRef
					&& targetMethod2.GetDeclaringTypeFullName() == "System.Threading.WaitCallback"
					&& targetMethod2.Name == ".ctor"
					) {
					var prevIns1 = instructionsBuffer[insIdx - 1].Item3;
					var prevIns2 = instructionsBuffer[insIdx - 2].Item3;
					var prevIns3 = instructionsBuffer[insIdx - 3].Item3;
					var prevIns4 = instructionsBuffer[insIdx - 4].Item3;

					var nextIns1 = instructionsBuffer[insIdx + 1].Item3;
					var nextIns2 = instructionsBuffer[insIdx + 2].Item3;
					var nextIns3 = instructionsBuffer[insIdx + 3].Item3;
					var nextIns4 = instructionsBuffer[insIdx + 4].Item3;

					if(prevIns4.OpCode.Code == Code.Ldsfld && prevIns4.Operand is FieldDef field4 && field4.FieldType.ToString() == "System.Threading.WaitCallback"
						&& prevIns3.OpCode.Code == Code.Brtrue_S
						&& prevIns2.OpCode.Code == Code.Ldnull
						&& prevIns1.OpCode.Code == Code.Ldftn
						&& nextIns3.OpCode.Code == Code.Call && nextIns3.Operand is MemberRef nmember3 && nmember3.IsMethodRef && nmember3.GetDeclaringTypeFullName() == "System.Threading.ThreadPool" && nmember3.Name == "QueueUserWorkItem"
						&& nextIns4.OpCode.Code == Code.Pop

						&& nextIns1.OpCode.Code == Code.Stsfld && nextIns1.Operand is FieldDef nfield1 && nfield1 == field4
						&& nextIns2.OpCode.Code == Code.Ldsfld && nextIns2.Operand is FieldDef nfield2 && nfield2 == field4) {
							for(int i=-4; i <= 4; i++) {
								junkInstructions.Add(Tuple.Create(instructionsBuffer[insIdx + i].Item1, instructionsBuffer[insIdx + i].Item2));
							}
					}
				}
			}

			foreach(var item in junkInstructions) {
				var blockNum = item.Item1;
				var blockInsNum = item.Item2;
				Logger.e($"Removing instruction: {allBlocks[blockNum].Instructions[blockInsNum]}");
				allBlocks[blockNum].Replace(blockInsNum, 1, OpCodes.Nop.ToInstruction());
			}
			return;
		}

		public override void DeobfuscateMethodBegin(Blocks blocks) {
			// Cannot use multi-pass to detect references to empty methods :(
			// FindEmptyMethods(blocks);
			// Logger.e($"Empty methods count: {emptyMethodTokens.Count}");
			// RemoveEmptyMethodThreads(blocks);
			base.DeobfuscateMethodBegin(blocks);
		}

		public override void DeobfuscateMethodEnd(Blocks blocks) {
			RemoveSimpleJunkCode(blocks);
			RemoveThreadJunkCode(blocks);
			base.DeobfuscateMethodEnd(blocks);
		}

		public override void DeobfuscateEnd() {
            foreach (var stringMethod in solarMakerStringMethods) {
                AddMethodToBeRemoved(stringMethod, "String decrypter method");
            }
			base.DeobfuscateEnd();
		}

		public override IEnumerable<int> GetStringDecrypterMethods() {
			var list = new List<int>();
            foreach(var method in solarMakerStringMethods) {
                list.Add(method.MDToken.ToInt32());
            }
			return list;
		}

        private static bool IsStringObfuscationMethod(MethodDef method) {
            if (method.Body.Instructions.Count < 10) {
                return false;
            }

            // Check that one of the first two instructions is a Ldstr
            if (method.Body.Instructions[0].OpCode != dnlib.DotNet.Emit.OpCodes.Ldstr
               && method.Body.Instructions[1].OpCode != dnlib.DotNet.Emit.OpCodes.Ldstr) {
                return false;
            }

            foreach (var instruction in method.Body.Instructions) {
                if (instruction.OpCode == dnlib.DotNet.Emit.OpCodes.Call) {
                    var calledMethod = instruction.Operand as MemberRef;
                    if (calledMethod == null) {
                        return false;
                    }
                    if (calledMethod.DeclaringType.FullName != "System.String" || calledMethod.Name != "Concat") {
                        return false;
                    }
                }
            }
            return true;
        }

        private static List<MethodDef> GetSolarMakerStringObfuscationFunctions(ModuleDefMD module) {
            List<MethodDef> obfuscatedStringMethods = new List<MethodDef>();
            IEnumerable<TypeDef> types = module.GetTypes();
            foreach(TypeDef type in types) {
                foreach(MethodDef method in type.Methods) {
                    var methodSig = method.MethodSig;
                    string methodName = method.FullName;
                    string methodReturnType = method.ReturnType.FullName;

                    if (!method.IsPrivate || !method.IsStatic || !method.HasBody) {
                        continue;
                    }
                    if (methodSig == null) {
                        continue;
                    }
                    if(methodSig.Params.Count != 0) {
                        continue;
                    }
                    if (methodReturnType != "System.String") {
                        continue;
                    }
                    if(method.Body.Variables[0].Type.FullName != "System.String") {
                        continue;
                    }
                    if(!IsStringObfuscationMethod(method)) {
                        continue;
                    }
                    obfuscatedStringMethods.Add(method);
                }
            }
            return obfuscatedStringMethods;
        }
	}
}
